<!DOCTYPE html>
<html lang="en">
<!--
PPPP   AAAAA  Y   Y  TTTTTT  OOOO   N   N
P   P  A   A   Y Y     TT   O    O  NN  N
PPPP   AAAAA    Y      TT   O    O  N N N
P      A   A    Y      TT   O    O  N  NN
P      A   A    Y      TT    OOOO   N   N

Author: Michael Payton
Project: Rumination
Date: June 2025
Notes: Currently a draft ready for overview and further development.
Changes/Additions: must add questionnaires, must add consent form, likely 
                   needs to load parameters from .csv file. 
-->

<head>
    <meta charset="UTF-8">
    <title>Mining Task</title>
    <script src="https://unpkg.com/jspsych@6.3.0/jspsych.js"></script>
    <script src="https://unpkg.com/jspsych@6.3.0/plugins/jspsych-html-button-response.js"></script>
    <script src="https://unpkg.com/jspsych@6.3.0/plugins/jspsych-call-function.js"></script>
    <script src="https://unpkg.com/jspsych@6.3.0/plugins/jspsych-html-slider-response.js"></script>
    <link href="https://unpkg.com/jspsych@6.3.0/css/jspsych.css" rel="stylesheet">
    <style>
        #balance {
            font-size: 1.2em;
            margin-bottom: 10px;
        }

        .jspsych-btn {
            font-size: 1em;
            padding: 10px 20px;
            margin: 0 5px;
        }

        /* 1) Widen the whole slider container and center it */
  .jspsych-html-slider-response-container {
    width: 600px !important;    /* 600px is a good starting place, right? */
    margin: 0 auto;
  }

  /* 2) Make the <input type="range"> fill that container */
  .jspsych-html-slider-response-container .jspsych-slider {
    width: 100% !important;
  }

  /* 3) Lay out all the labels in a row */
  .jspsych-html-slider-response-text {
    display: flex;
    justify-content: space-between;
    margin-top: 10px;
  }

  /* 4) Box each label so they don‚Äôt bleed together */
  .jspsych-html-slider-response-text span {
    flex: 1;
    border: 1px solid #ccc;
    padding: 6px;
    margin: 0 4px;
    text-align: center;
    background: #f9f9f9;
    border-radius: 4px;
    white-space: nowrap;
    box-sizing: border-box;
  }
    </style>
</head>

<body>
    <div id="jspsych-target"></div>
    <script>
        // Parameters
        const N_BLOCKS = 2; // must match number of blocks in per-block overrides
        const TRIALS_PER_BLOCK = 2;
        const STARTING_MONEY = 100;
        const NOISE = 0.65;   // Scanner noise, probability of a correct scan
        const SCAN_COST = 1;
        const REWARD = 50;   // reward if correct
        const PENALTY = 100; // penalty if incorrect

        // Optional per-block overrides (fall back to the defaults above)
            const BLOCK_PARAMS = [
                { NOISE: 0.65, SCAN_COST: 1, REWARD: 50, PENALTY: 100 }, // Block 1
                { NOISE: 0.55, SCAN_COST: 5, REWARD: 50, PENALTY: 120 }    // Block 2
                // Edit: we will add more objects once we decide how many blocks/trials to
            ];

            // "Current" parameters 
            let pNoise = NOISE;
            let pScanCost = SCAN_COST;
            let pReward = REWARD;
            let pPenalty = PENALTY;

            function applyBlockParams(b) {
                const p = BLOCK_PARAMS[b] || {};
                pNoise = (p.NOISE !== undefined) ? p.NOISE : NOISE;
                pScanCost = (p.SCAN_COST !== undefined) ? p.SCAN_COST : SCAN_COST;
                pReward = (p.REWARD !== undefined) ? p.REWARD : REWARD;
                pPenalty = (p.PENALTY !== undefined) ? p.PENALTY : PENALTY;
            }


        // Starting Counters
        let currentMoney = STARTING_MONEY;
        let trueState;    // gold is in either at the "surface" or in the "core"
        let scanMsg;      // message given by scanner
        let lastDig = null;
        let lastCorrect = null;
        let scanCoreCount = 0;
        let scanSurfaceCount = 0;
        let scanCount = 0;      // total scans this trial

        // track where we are in blocks/trials
            let globalBlockIndex = 0;
            let globalTrialIndex = 0;

        // new asteroid, reset observation and counters
        function resetAsteroid() {
            trueState = (Math.random() < 0.5) ? 'surface' : 'core';
            scanMsg = null;
            scanCoreCount = 0;
            scanSurfaceCount = 0;
            scanCount = 0;
        }

        // Trial: scan vs dig
            const scanOrDig = {
                type: 'html-button-response',
                stimulus: function () {
                    const blocksLeft = N_BLOCKS - (globalBlockIndex + 1);
                    const trialsDone = globalTrialIndex + 1;
                    const trialsLeft = TRIALS_PER_BLOCK - trialsDone;
                    return `
  <div id="balance">Gold: <strong>${currentMoney}</strong></div>
  <div>Asteriod Field ${globalBlockIndex + 1} of ${N_BLOCKS} (Asteroid Fields left: ${blocksLeft})</div>
  <div>Asteroid ${trialsDone} of ${TRIALS_PER_BLOCK} (Asteriods left: ${trialsLeft})</div>
  <p>Current scanner observation: <strong>${scanMsg || 'None'}</strong></p>
  <p>Total number of Scans indicating Core: <strong>${scanCoreCount}</strong></p>
  <p>Total number of Scans indicating Surface: <strong>${scanSurfaceCount}</strong></p>
  <p>Scan accuracy: <strong>${Math.round(pNoise * 100)}%</strong></p>
  <p>Scan cost: <strong>${pScanCost}</strong> gold</p>
  <p>Gold for correct dig: <strong>${pReward}</strong> gold</p>
  <p>Gold lost for incorrect dig: <strong>${pPenalty}</strong> gold</p>

 
        `;
                },
                choices: ['üîç Scan', '‚õè Dig in Core', 'üåê Dig at Surface'],
                on_finish: function (data) {
                    const choice = parseInt(data.response);
                    if (choice === 0) {
                        // -------- SCAN --------
                        data.scan = true;
                        currentMoney -= pScanCost;
                        // noisy observation
                        const obs = (Math.random() < pNoise)
                            ? trueState
                            : (trueState === 'surface' ? 'core' : 'surface');
                        scanMsg = (obs === 'surface')
                            ? 'Scanners suggest there is gold at the surface'
                            : 'Scanners suggest there is gold in the core';
                        // update counters
                        if (obs === 'surface') {
                            scanSurfaceCount++;
                        } else {
                            scanCoreCount++;
                        }
                        scanCount++;
                    } else {
                        // -------- DIG --------
                        data.scan = false;
                        const dug = (choice === 1) ? 'core' : 'surface';
                        const correct = (dug === trueState);
                        // imperatively update balance with per-block values
                        if (correct) {
                            currentMoney += pReward;
                        } else {
                            currentMoney -= pPenalty;
                        }
                        data.correct = correct;
                        data.delta = correct ? pReward : -pPenalty;
                        data.dug = dug;
                        data.scanCount = scanCount;  // total scans this trial
                    }
                    // record scan counters every time
                    data.scanCount = scanCount;
                    data.scanCoreCount = scanCoreCount;
                    data.scanSurfaceCount = scanSurfaceCount;
                    // rt is already logged by html-button-response
                }

            };


        // loop until they choose to dig, allows infinite scanning
        const scanOrDigLoop = {
            timeline: [scanOrDig],
            loop_function: function (data) {
                const last = data.values().slice(-1)[0];
                return parseInt(last.response) === 0;  // keep looping if they scanned
            }
        };

        // Feedback after each dig
        const digFeedback = {
            type: 'html-button-response',
            choices: [],    // no buttons
            stimulus: function () {
                // Grab all data, reverse it, and find the first trial where we actually dug
                const allData = jsPsych.data.get().values();
                const digData = allData
                    .slice()                      // copy
                    .reverse()                    // last trial first
                    .find(trial => trial.dug);    // only dig trials have `dug` defined

                return `
      <div id="balance">Gold: <strong>${currentMoney}</strong></div>
      ${digData.correct
                        ? `<p>You struck gold! (+${pReward})</p>`
                        : `<p>Better luck next time! (‚àí${pPenalty})</p>`
                    }
    `;
            },
            trial_duration: 1500
        };

        // Confidence slider after each dig
        const confidenceTrial = {
                type: 'html-slider-response',
                // Fill in stimulus & labels in on_start
                stimulus: '',
                labels: [],
                min: 0,
                max: 100,
                start: 50,
                step: 1,
                require_movement: true,
                data: { trial_part: 'confidence' },

                on_start: function (trial) {
                    // grab all data, reverse, and find the most recent dig trial
                    const all = jsPsych.data.get().values();
                    const digData = all.slice().reverse().find(t => t.dug !== undefined);
                    const choice = digData.dug; // either "core" or "surface"

                    // set the question text
                    trial.stimulus = `<p>How confident are you that the gold is at <strong>${choice}</strong>?</p>`;

                    // set the endpoint and midpoint labels
                    trial.labels = [
                        `Not confident that gold is at ${choice}`,
                        `Moderately confident that gold is at ${choice}`, // may need workshoping
                        `Very confident that gold is at ${choice}`
                    ];
                },

                on_finish: function (data) {
                    data.confidence = data.response;
                }
            };


        // Comprehension Check
            // running tallies saved across attempts and will be saved in csv output
            const quizStats = {
                stay_put: { correct: 0, incorrect: 0 },
                noise_def: { correct: 0, incorrect: 0 },
                scan_tradeoff: { correct: 0, incorrect: 0 }
            };

            // helper function: creates a single-question loop with feedback and logging for csv
            function makeQuizQuestion({ qid, promptHTML, choices, correctIndex, feedbackHTML }) {
                let attempts = 0; // attempts for this question (resets if page reloads)

                const qTrial = {
                    type: 'html-button-response',
                    stimulus: promptHTML,
                    choices: choices,
                    data: { trial_part: 'instr', qid: qid },
                    on_finish: function (d) {
                        attempts += 1;
                        d.attempt = attempts;
                        d.correct_index = correctIndex;
                        d.is_correct = (d.response === correctIndex);

                        // update totals
                        if (d.is_correct) quizStats[qid].correct += 1;
                        else quizStats[qid].incorrect += 1;

                        // copy running totals into this row so they get added to the CSV
                        d.correct_total = quizStats[qid].correct;
                        d.incorrect_total = quizStats[qid].incorrect;
                    }
                };

                const feedbackTrial = {
                    type: 'html-button-response',
                    choices: function () {
                        const last = jsPsych.data.get().last(1).values()[0];
                        return last.is_correct ? [] : ['Try again'];
                    },
                    stimulus: function () {
                        const last = jsPsych.data.get().last(1).values()[0]; // the question we just answered
                        if (last.is_correct) {
                            return `<p>‚úÖ Correct.</p>`;
                        } else {
                            return `
                        <p>‚ùå Incorrect.</p>
                        <div style="margin-top:8px">${feedbackHTML}</div>
                        <p style="margin-top:8px">Please select the correct answer to continue.</p>
                        `;
                        }
                    },
                    trial_duration: function () {
                        const last = jsPsych.data.get().last(1).values()[0];
                        return last.is_correct ? 900 : null; // auto-advance if correct; else wait for button
                    },
                    data: { trial_part: 'instr_feedback', qid: qid }
                };

                // repeat forever until the questions get answered correctly
                return {
                    timeline: [qTrial, feedbackTrial],
                    loop_function: function (loopData) {
                        // the first item in this mini-timeline is the question trial we just ran
                        const q = loopData.values().find(t => t.trial_part === 'instr' && t.qid === qid);
                        return !q.is_correct; // true ‚Üí repeat; false ‚Üí move on
                    }
                };
            }

            // Q1: which action keeps you on the same asteroid?
            const quizQ1 = makeQuizQuestion({
                qid: 'stay_put',
                promptHTML: `<p><strong>1.</strong> Which action keeps you on the same asteroid and gather information about where to dig?</p>`,
                choices: ['üîç Scan', '‚õè Dig Core', 'üåê Dig Surface'],
                correctIndex: 0,
                feedbackHTML: `<p>Incorrect. Scanning both gives you information about the asteroid and does <em>not</em> end the trial. It provides some noisy information at a cost set by the company. You can <em>scan</em> repeatedly on the same asteroid.</p>`
            });

            // Q2: meaning of ‚Äúscanner noise 70%‚Äù
            const quizQ2 = makeQuizQuestion({
                qid: 'noise_def',
                promptHTML: `<p><strong>2.</strong> Our scanners are <strong>UNRELIABLE</strong> and they have scanner noise. Suppose scanner noise is 70%. What does this mean?</p>`,
                choices: [
                    'I can trust that the scanner is giving me the right answer most of the time.',
                    'The scanner makes a noise at 70% volume.',
                    'The scanner is only giving the correct location 70% of the time.'
                ],
                correctIndex: 2,
                feedbackHTML: `<p>Incorrect. The ‚Äú70%‚Äù means the scanner‚Äôs message matches the true gold location 70% of the time.</p>`
            });

            // Q3: scanning trade-off
            const quizQ3 = makeQuizQuestion({
                qid: 'scan_tradeoff',
                promptHTML: `<p><strong>3.</strong> Suppose you got three "surface" readings in a row and no "core" readings. Should you dig at the surface?</p>`,
                choices: [
                    'Yes, that is a strong indication of gold on the surface.',
                    'No, the scanner is unreliable, so you should ignore it.',
                    'Maybe. It depends on the scanner reliability, the cost of a scan, and the company reward and punishment.'
                ],
                correctIndex: 2,
                feedbackHTML: `<p>Incorrect. The right time to dig depends on scanner accuracy, scan cost, and your reward/penalty structure. You should not just rely on last few scanner readings.</p>`
            });



        // Build the experiment timeline 
        const timeline = [];
        
        //Instructions now broken into multiple pages due to length. 

        // Instructions 1 
        timeline.push({
            type: 'html-button-response',
            stimulus: `
        <h2>Mining Task (Draft instructions)</h2>
        <p>In this experiment, your will pretend to work for an asteroid mining company in the year 3000.</p>
        <p>The company has sent mining drones all over the galaxy. Your job is to help us collect gold from asteroids.</p>
        <p>Each asteroid a mining drone lands on has gold at the surface or in the core.</p>
        <p>But we don't know whether gold is near the surface or in the core.</p>
        `,
            choices: ['Next']
        });

        // Instructions 2
            timeline.push({
                type: 'html-button-response',
                stimulus: `
        <p>Your task is to decide whether to dig near the surface or into the core.</p>
        <p>If you dig where the gold is located, then you will get a reward as compensation from the company. However, the asteroids are <strong>fragile.</strong></p> 
        <p>So, once you dig, it will break apart and any remaining gold becomes unsalvageable.</p>  
        <p>If you dig in the incorrect location, you cannot get the gold and the company will penalize you by lowering your compensation.</p>  
        <p>To help you, you can pay a small amount to scan the asteroid. Unfortunately, the scanners are <strong>unreliable.</strong></p> 
        <p>You can scan each asteroid as many times as you want. But, scanning is costly and so, the company charges you given amount per scan.</p>
        `,
                choices: ['Next']
            });

          // Instructions 3
            timeline.push({
                type: 'html-button-response',
                stimulus: `  
        <p>You start with <strong>${STARTING_MONEY}</strong> gold.</p>
        <p>When you land on an asteroid, you have a options about what to do:</p>
        <p>üîç <strong>Scan</strong> (cost depends on the specific asteriod field): you get noisy info about the location of the gold.</p>
        <p>‚õè <strong>Dig Core</strong> or üåê <strong>Dig Surface</strong>.</p>
        <p>If you select the correct location to dig: You win gold.</p> 
        <p>If you select the incorrect location to dig: You lose gold.</p>
        <p>Scan as many times as you like to gain information about the gold location.</p> 
        `,
                choices: ['Next']
            });

        // Instructions 4
            timeline.push({
                type: 'html-button-response',
                stimulus: `
        <p>You only get to pick a dig location once for each asteroid. So please make sure you're ready to dig in which ever location before doing so.</p>
        <p>The scanner's reliability, cost of using the scanner, reward, and punishment are set by the company for each particular asteroid. You will be told their amounts each time.</p>
        <p>Your compensation for the experiment partially depends on your <strong>total gold balance.</strong></p>
        
        `,
                choices: ['Next']
            });

        // Instructions 5
            timeline.push({
                type: 'html-button-response',
                stimulus: `
                <p>Before we send you to the first asteriod field, we will check your understanding of the actions available and your role in the mission.</p>
                <p>Press <strong>Start</strong> to begin.</p>
      `,
            choices: ['Start']
        });

        // comprehension check ‚Äì each question loops until correct - Joe's preference
            timeline.push(quizQ1, quizQ2, quizQ3);


        // initialize first asteroid
        timeline.push({ type: 'call-function', func: resetAsteroid });

       // blocks
        for (let b = 0; b < N_BLOCKS; b++) {

            // set current block index so the main trial screen shows the right block number
            timeline.push({
                type: 'call-function',
                func: () => { globalBlockIndex = b; applyBlockParams(b); }
            });

            // block reminder parameter reminder text
            timeline.push({
                type: 'html-button-response',
                stimulus: function () {
                    return `
            <h3>Asteroid Field ${b + 1} of ${N_BLOCKS}</h3>
            <p>You have now travelled to a new asteroid field.</p>
            <p>The company has determined new values for scanner reliability, cost, reward and penalty for this asteroid field:</p>
            <ul>
              <li>Scanner accuracy: ${Math.round(pNoise * 100)}%</li>
              <li>Scan cost: ${pScanCost} gold</li>
              <li>Reward: +${pReward} gold</li>
              <li>Penalty: ‚àí${pPenalty} gold</li>

            </ul>
            <p>Your balance carries over.</p>
            <p>Press <strong>Continue</strong> when ready.</p>
          `;
                },
                choices: ['Continue']
            });

            // trials
            for (let t = 0; t < TRIALS_PER_BLOCK; t++) {
                // record which trial (within the current block) we're on
                timeline.push({
                    type: 'call-function',
                    func: () => { globalTrialIndex = t; }
                });

                timeline.push(scanOrDigLoop);
                timeline.push(confidenceTrial);
                timeline.push(digFeedback);
                timeline.push({ type: 'call-function', func: resetAsteroid });
            }
        }

       // final screen
        timeline.push({
            type: 'html-button-response',
            stimulus: function () {
                return `
      <h2>Congratulations on a successful space mining adventure!</h2>
      <p>Your final balance: <strong>${currentMoney}</strong> gold.</p>
      <p>Thank you for participating in our experiments.</p>
    `;
            },
            choices: ['Finish and download'] // 
        });

            // launch the experiment
                jsPsych.init({
                    timeline: timeline,
                    display_element: document.getElementById('jspsych-target'),
                    on_finish: function () {
                        // this will download data as CSV when participant clicks ‚ÄúFinish and download‚Äù
                        jsPsych.data.get().localSave('csv', 'mining_task_data.csv');
                    }
                });


    </script>
</body>

</html>