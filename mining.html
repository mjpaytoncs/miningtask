<!DOCTYPE html>
<html lang="en">
<!--
PPPP   AAAAA  Y   Y  TTTTTT  OOOO   N   N
P   P  A   A   Y Y     TT   O    O  NN  N
PPPP   AAAAA    Y      TT   O    O  N N N
P      A   A    Y      TT   O    O  N  NN
P      A   A    Y      TT    OOOO   N   N

Author: Michael Payton
Project: Rumination
Date: August 2025
Notes: Currently a draft ready for overview and further development.
Changes/Additions: must add questionnaires, must add consent form, likely 
                   needs to load parameters from .csv file. 

Edit Notes (2025-09-11):
- Implemented Versioning constant and per-row logging.
- Implemented Participant metadata (ID/session/timestamp) captured via prompts and added to all rows.
- Implemented File naming to include participant ID and ISO timestamp.
- Implemented Data schema completeness for dig rows (block_index, trial_index, pre_balance, post_balance, cumulative_scan_cost).
- Removed leading spaces from PTQ preamble and items 14 and 15 to eliminate invisible indentation. No wording changed.
- Added CSS fallback to center horizontal multi-choice options when no <ul> wrapper is present. Non-destructive and scoped to jspsych survey classes.
- Set survey layout to vertical for Q's by adding horizontal:false at the set level. Presentation only. Data schema unchanged.
- Added HUD style to task and loading screen
- Added demographic questions
- Added ghost counter "+1" to scan action
- Added ping to scan counter
-->

<head>
    <meta charset="UTF-8">
    <title>Mining Task</title>
    <script src="https://unpkg.com/jspsych@6.3.0/jspsych.js"></script>
    <script src="https://unpkg.com/jspsych@6.3.0/plugins/jspsych-html-button-response.js"></script>
    <script src="https://unpkg.com/jspsych@6.3.0/plugins/jspsych-call-function.js"></script>
    <script src="https://unpkg.com/jspsych@6.3.0/plugins/jspsych-html-slider-response.js"></script>
    <script src="https://unpkg.com/jspsych@6.3.0/plugins/jspsych-survey-multi-choice.js"></script>
    <script src="https://unpkg.com/jspsych@6.3.0/plugins/jspsych-instructions.js"></script>
    <link href="https://unpkg.com/jspsych@6.3.0/css/jspsych.css" rel="stylesheet">
    <style>
        #balance {
            font-size: 1.2em;
            margin-bottom: 10px;
        }

        .jspsych-btn {
            font-size: 1em;
            padding: 10px 20px;
            margin: 0 5px;
        }

        /* 1) Widen the whole slider container and center it */
        .jspsych-html-slider-response-container {
            width: 600px !important;
            /* 600px is a good starting place, right? */
            margin: 0 auto;
        }

        /* 2) Make the <input type="range"> fill that container */
        .jspsych-html-slider-response-container .jspsych-slider {
            width: 100% !important;
        }

        /* 3) Lay out all the labels in a row */
        .jspsych-html-slider-response-text {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
        }

        /* 4) Box each label so they don‚Äôt bleed together */
        .jspsych-html-slider-response-text span {
            flex: 1;
            border: 1px solid #ccc;
            padding: 6px;
            margin: 0 4px;
            text-align: center;
            background: #f9f9f9;
            border-radius: 4px;
            white-space: nowrap;
            box-sizing: border-box;
        }

        /* Center horizontal survey choices even when there is no <ul> wrapper */
        .jspsych-survey-multi-choice .jspsych-survey-multi-choice-horizontal {
            text-align: center;
        }

        .jspsych-survey-multi-choice .jspsych-survey-multi-choice-horizontal .jspsych-survey-multi-choice-option {
            display: inline-flex;
            /* keeps radio + label together */
            align-items: center;
            /* vertical align radio and text */
            margin: 0 18px;
            /* match existing spacing */
        }

        /* optional: tiny gap between radio and label, non-destructive */
        .jspsych-survey-multi-choice .jspsych-survey-multi-choice-horizontal .jspsych-survey-multi-choice-option input {
            margin-right: 6px;
        }

        /* Force-center horizontal options even without a <ul> wrapper */
        .jspsych-survey-multi-choice .jspsych-survey-multi-choice-horizontal {
            text-align: center !important;
            /* center inline children */
        }

        .jspsych-survey-multi-choice .jspsych-survey-multi-choice-horizontal .jspsych-survey-multi-choice-option {
            display: inline-block !important;
            /* sit side-by-side */
            width: auto !important;
            /* no 100% width blocks */
            margin: 0 18px !important;
            /* spacing like before */
            vertical-align: middle !important;
            text-align: left !important;
            /* keep label text left */
        }

        .jspsych-survey-multi-choice .jspsych-survey-multi-choice-horizontal .jspsych-survey-multi-choice-option input {
            margin-right: 6px !important;
            /* small gap radio‚Üílabel */
        }

        /* ===== HUD / "spaceship console" look ===== */
.hud {
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  background: radial-gradient(120% 80% at 50% 0%, #0b1220 0%, #061019 60%);
  color: #cfe8ff;
  border: 1px solid rgba(80,180,255,.35);
  border-radius: 12px;
  padding: 14px;
  box-shadow:
    0 0 0 1px rgba(80,180,255,.18),
    0 10px 28px rgba(0,0,0,.45),
    inset 0 0 28px rgba(80,180,255,.08);
}

.hud-header {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
  margin-bottom: 10px;
}

.hud-balance {
  font-size: 1.3rem;
  letter-spacing: .4px;
}

.hud-meta {
  display: grid;
  grid-auto-flow: column;
  gap: 14px;
  align-items: center;
  opacity: .95;
}

.hud-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
  gap: 12px;
}

.hud-card {
  background: rgba(255,255,255,.04);
  border: 1px solid rgba(80,180,255,.22);
  border-radius: 10px;
  padding: 10px 12px;
}

.hud-card p { margin: 6px 0; }

.hud-divider {
  height: 1px;
  margin: 8px 0;
  background: linear-gradient(90deg, transparent, rgba(80,180,255,.35), transparent);
}

/* subtle highlight for numbers */
.hud strong { color: #fff; }

/* keeps layout tidy on very small screens */
@media (max-width: 480px) {
  .hud-meta { grid-auto-flow: row; gap: 6px; }
}

/* Buttons for the Scan/Core/Surface choices on the HUD screen */
.hud-actions {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 12px;
  flex-wrap: wrap;
  margin-top: 14px;
}

.hud-btn {
  font-family: inherit;
  font-size: 1rem;
  padding: 10px 16px;
  border-radius: 10px;
  border: 1px solid rgba(80,180,255,.35);
  background: rgba(255,255,255,.06);
  color: #cfe8ff;
  box-shadow:
    0 0 0 1px rgba(80,180,255,.18),
    inset 0 0 18px rgba(80,180,255,.08);
  cursor: pointer;
}

.hud-btn:hover { background: rgba(255,255,255,.10); }
.hud-btn:focus { outline: none; box-shadow: 0 0 0 2px rgba(80,180,255,.55); }

/* Force this HUD to stack cards vertically */
.hud-grid.hud-stack { grid-template-columns: 1fr; }

/* Make the action button group look like a HUD card (dark) */
.hud { margin-bottom: 10px; } /* small gap above the buttons */

.hud-actions {
  display: flex;
  justify-content: center;
  align-items: center;
  flex-wrap: wrap;
  gap: 12px;

  background: rgba(8,16,26,.88);
  border: 1px solid rgba(80,180,255,.22);
  border-radius: 10px;
  padding: 12px;
  box-shadow:
    inset 0 0 28px rgba(80,180,255,.08),
    0 10px 28px rgba(0,0,0,.25);

  width: 100%;
  box-sizing: border-box;
}

/* Make buttons solid and console-like (override any defaults) */
.hud-btn {
  font-family: inherit;
  font-size: 1rem;
  padding: 10px 16px;
  border-radius: 10px;
  border: 1px solid rgba(80,180,255,.35) !important;
  background: rgba(16,32,48,.9) !important;   /* darker fill */
  color: #cfe8ff !important;
  box-shadow:
    0 0 0 1px rgba(80,180,255,.18),
    inset 0 0 18px rgba(80,180,255,.10);
  cursor: pointer;
  opacity: 1 !important; /* prevent washed-out look */
}

.hud-btn:hover { background: rgba(22,44,66,.95) !important; }
.hud-btn:focus { outline: none; box-shadow: 0 0 0 2px rgba(80,180,255,.55) !important; }

/* === Scan feedback === */
.scan-flash { animation: scanFlash 600ms ease-out; }
@keyframes scanFlash {
  0%   { box-shadow: 0 0 0 2px rgba(80,180,255,.45), inset 0 0 26px rgba(80,180,255,.22); }
  100% { box-shadow: 0 0 0 0 rgba(80,180,255,0),     inset 0 0 0   rgba(0,0,0,0); }
}

.count-bump { animation: countBump 320ms ease-out; transform-origin: 50% 60%; }
@keyframes countBump {
  0%   { transform: scale(1.00); color:#cfe8ff; }
  50%  { transform: scale(1.25); color:#ffffff; }
  100% { transform: scale(1.00); color:#cfe8ff; }
}

.delta { margin-left: 6px; font-weight: 600; opacity: 0; }
.delta.show { animation: deltaPop 820ms ease-out forwards; }
@keyframes deltaPop {
  0%   { opacity: 0; transform: translateY(4px); }
  20%  { opacity: 1; }
  100% { opacity: 0; transform: translateY(-6px); }
}

.new-badge {
  margin-left: 8px; font-size: .72rem; padding: 2px 6px;
  border-radius: 999px; border: 1px solid rgba(80,180,255,.35);
  background: rgba(80,180,255,.14);
}


    </style>
</head>

<body>
    <div id="jspsych-target"></div>
    <script>
        // ======== Versioning ========
        const TASK_VERSION = 'mining_task_2025-09-11_v2';

        // ========  Prolific completion URL ======== 
        // (replace XXXXXXXX with code from Prolific)
            const PROLIFIC_COMPLETION_URL =
                'https://app.prolific.com/submissions/complete?cc=XXXXXXXX';


        // Parameters
        const N_BLOCKS = 1; // must match number of blocks in per-block overrides
        const TRIALS_PER_BLOCK = 1;
        const STARTING_MONEY = 100;
        const NOISE = 0.65;   // scanner accuracy, probability of a correct scan
        const SCAN_COST = 1;
        const REWARD = 50;   // reward if correct
        const PENALTY = 100; // penalty if incorrect

        // Optional per-block overrides (fall back to the defaults above)
        const BLOCK_PARAMS = [
            { NOISE: 0.65, SCAN_COST: 1, REWARD: 50, PENALTY: 100 }, // Block 1
            { NOISE: 0.55, SCAN_COST: 5, REWARD: 50, PENALTY: 120 }    // Block 2
            // Edit: we will add more objects once we decide how many blocks/trials to
        ];

        // "Current" parameters 
        let pNoise = NOISE;
        let pScanCost = SCAN_COST;
        let pReward = REWARD;
        let pPenalty = PENALTY;

        function applyBlockParams(b) {
            const p = BLOCK_PARAMS[b] || {};
            pNoise = (p.NOISE !== undefined) ? p.NOISE : NOISE;
            pScanCost = (p.SCAN_COST !== undefined) ? p.SCAN_COST : SCAN_COST;
            pReward = (p.REWARD !== undefined) ? p.REWARD : REWARD;
            pPenalty = (p.PENALTY !== undefined) ? p.PENALTY : PENALTY;
        }


        // Starting Counters
        let currentMoney = STARTING_MONEY;
        let trueState;    // gold is in either at the "surface" or in the "core"
        let scanMsg;      // message given by scanner
        let lastDig = null;
        let lastCorrect = null;
        let scanCoreCount = 0;
        let scanSurfaceCount = 0;
        let scanCount = 0;      // total scans this trial

        // Visual/audio cue helpers
            let lastAction = null;         // 'scan' | 'dig' | null
            let lastObsType = null;        // 'surface' | 'core' | null
            const ENABLE_SCAN_SOUND = true;
            let _audioCtx = null;
            function playScanPing() {
                if (!ENABLE_SCAN_SOUND) return;
                try {
                    _audioCtx = _audioCtx || new (window.AudioContext || window.webkitAudioContext)();
                    const o = _audioCtx.createOscillator();
                    const g = _audioCtx.createGain();
                    o.type = 'sine';
                    o.frequency.value = 1046;          // soft, bright ‚Äòping‚Äô
                    o.connect(g);
                    g.connect(_audioCtx.destination);
                    const now = _audioCtx.currentTime;
                    g.gain.setValueAtTime(0.0001, now);
                    g.gain.exponentialRampToValueAtTime(0.09, now + 0.01);
                    g.gain.exponentialRampToValueAtTime(0.0001, now + 0.16);
                    o.start(now);
                    o.stop(now + 0.18);
                } catch (_) { /* ignore */ }
            }


        // track where we are in blocks/trials
        let globalBlockIndex = 0;
        let globalTrialIndex = 0;

        // ======== (#2) Participant metadata collection (prompts) ========
        // Captured before any trials; added to all rows via addProperties.
        let PARTICIPANT_ID = 'NA';
        let SESSION_ID = 'NA';
        let START_TIMESTAMP = new Date().toISOString();

        function collectParticipantMetadata() {
                const q = new URLSearchParams(window.location.search);
                const prolific_pid = q.get('PROLIFIC_PID');  // participant
                const prolific_study = q.get('STUDY_ID');      // study
                const prolific_sess = q.get('SESSION_ID');    // session/submission

                START_TIMESTAMP = new Date().toISOString();

                if (prolific_pid) {
                    // Use Prolific-provided IDs
                    PARTICIPANT_ID = prolific_pid;
                    SESSION_ID = prolific_sess || 'NA';

                    jsPsych.data.addProperties({
                        task_version: TASK_VERSION,
                        participant_id: prolific_pid,          // keep your existing column name
                        prolific_pid: prolific_pid,            // explicit Prolific fields too
                        prolific_study_id: prolific_study || 'NA',
                        prolific_session_id: prolific_sess || 'NA',
                        start_timestamp: START_TIMESTAMP,
                        source: 'prolific'
                    });
                } else {
                    // Fallback to your manual prompts (as you had before)
                    try {
                        const pid = window.prompt('Participant ID (required):', '') || 'NA';
                        const sid = window.prompt('Session ID (optional):', '') || 'NA';
                        PARTICIPANT_ID = String(pid).trim() || 'NA';
                        SESSION_ID = String(sid).trim() || 'NA';
                    } catch (_) { /* ignore */ }

                    jsPsych.data.addProperties({
                        task_version: TASK_VERSION,
                        participant_id: PARTICIPANT_ID,
                        session_id: SESSION_ID,
                        start_timestamp: START_TIMESTAMP,
                        source: 'local'
                    });
                }
            }


        // new asteroid, reset observation and counters
        function resetAsteroid() {
                trueState = (Math.random() < 0.5) ? 'surface' : 'core';
                scanMsg = null;
                scanCoreCount = 0;
                scanSurfaceCount = 0;
                scanCount = 0;
                lastAction = null;            // 
                lastObsType = null;           // 
            }


        // Trial: scan vs dig
            const scanOrDig = {
                type: 'html-button-response',
                stimulus: function () {
                    const blocksLeft = N_BLOCKS - (globalBlockIndex + 1);
                    const trialsDone = globalTrialIndex + 1;
                    const trialsLeft = TRIALS_PER_BLOCK - trialsDone;

                    const justScanned = (lastAction === 'scan');                   // NEW
                    const scannerCardClass = `hud-card ${justScanned ? 'scan-flash' : ''}`; // NEW
                    const coreBumpClass = justScanned && lastObsType === 'core' ? 'count-bump' : '';      // NEW
                    const surfBumpClass = justScanned && lastObsType === 'surface' ? 'count-bump' : '';   // NEW
                    const coreDeltaClass = justScanned && lastObsType === 'core' ? 'delta show' : 'delta';// NEW
                    const surfDeltaClass = justScanned && lastObsType === 'surface' ? 'delta show' : 'delta'; // NEW

                    return `
    <div class="hud">
      <div class="hud-header">
        <div class="hud-balance" id="balance">Gold: <strong>${currentMoney}</strong></div>
        <div class="hud-meta">
          <div>Asteroid Field ${globalBlockIndex + 1} of ${N_BLOCKS} (Asteroid Fields left: ${blocksLeft})</div>
          <div>Asteroid ${trialsDone} of ${TRIALS_PER_BLOCK} (Asteroids left: ${trialsLeft})</div>
        </div>
      </div>

      <div class="hud-grid hud-stack">
        <!-- Parameters card FIRST, so it appears on top -->
        <div class="hud-card">
          <p>Scan accuracy: <strong>${Math.round(pNoise * 100)}%</strong></p>
          <div class="hud-divider"></div>
          <p>Scan cost: <strong>${pScanCost}</strong> gold</p>
          <div class="hud-divider"></div>
          <p>Gold for correct dig: <strong>${pReward}</strong> gold</p>
          <div class="hud-divider"></div>
          <p>Gold lost for incorrect dig: <strong>${pPenalty}</strong> gold</p>
        </div>

        <!-- Scanner readout card SECOND -->
        <div class="${scannerCardClass}">
          <p>
            Current scanner observation:
            <strong>${scanMsg || 'None'}</strong>
            ${(lastAction === 'scan' && scanMsg) ? '<span class="new-badge">NEW</span>' : ''}
          </p>
          <div class="hud-divider"></div>
          <p>
            Total Scans indicating Core:
            <strong class="${coreBumpClass}">${scanCoreCount}</strong>
            <span class="${coreDeltaClass}">+1</span>
          </p>
          <p>
            Total Scans indicating Surface:
            <strong class="${surfBumpClass}">${scanSurfaceCount}</strong>
            <span class="${surfDeltaClass}">+1</span>
          </p>
        </div>

      </div>
    </div>
    `;
                },

                // exact same labels, just styled
                choices: ['üîç Scan', '‚õè Dig in Core', 'üåê Dig at Surface'],

                // use HUD-styled buttons for this trial only
                button_html: '<button class="jspsych-btn hud-btn">%choice%</button>',

                // center the button group under the HUD
                on_load: function () {
                    const g = document.getElementById('jspsych-html-button-response-btngroup');
                    if (g) g.classList.add('hud-actions');
                },

                on_finish: function (data) {
                    const choice = parseInt(data.response);

                    // ======== (#5) Capture indices for this action row ========
                    data.block_index = globalBlockIndex;
                    data.trial_index = globalTrialIndex;

                    if (choice === 0) {
                        // -------- SCAN --------
                        data.scan = true;
                        // track pre/post for completeness (scan row)
                        const pre_balance_scan = currentMoney;
                        currentMoney -= pScanCost;
                        const post_balance_scan = currentMoney;
                        data.pre_balance = pre_balance_scan;
                        data.post_balance = post_balance_scan;

                        // noisy observation
                        const obs = (Math.random() < pNoise)
                            ? trueState
                            : (trueState === 'surface' ? 'core' : 'surface');
                        scanMsg = (obs === 'surface')
                            ? 'Scanners suggest there is gold at the surface'
                            : 'Scanners suggest there is gold in the core';
                            lastAction = 'scan';
                        lastObsType = obs;           // 'core' or 'surface'
                        playScanPing();              // optional soft ping

                        // update counters
                        if (obs === 'surface') {
                            scanSurfaceCount++;
                        } else {
                            scanCoreCount++;
                        }
                        scanCount++;
                    } else {
                        // -------- DIG --------
                         lastAction = 'dig';
                        lastObsType = null;

                        data.scan = false;

                        // ======== (#5) pre/post balance and cumulative scan cost on dig row ========
                        const pre_balance = currentMoney; // before applying reward/penalty
                        const dug = (choice === 1) ? 'core' : 'surface';
                        const correct = (dug === trueState);

                        if (correct) {
                            currentMoney += pReward;
                        } else {
                            currentMoney -= pPenalty;
                        }

                        const post_balance = currentMoney;
                        const cumulative_scan_cost = scanCount * pScanCost;

                        data.correct = correct;
                        data.delta = correct ? pReward : -pPenalty;
                        data.dug = dug;
                        data.scanCount = scanCount;  // total scans this trial
                        data.scanCoreCount = scanCoreCount;
                        data.scanSurfaceCount = scanSurfaceCount;

                        // add completeness fields
                        data.pre_balance = pre_balance;
                        data.post_balance = post_balance;
                        data.cumulative_scan_cost = cumulative_scan_cost;
                    }
                    // record scan counters every time
                    data.scanCount = scanCount;
                    data.scanCoreCount = scanCoreCount;
                    data.scanSurfaceCount = scanSurfaceCount;
                    // rt is already logged by html-button-response
                }
            };



        // loop until they choose to dig, allows infinite scanning
        const scanOrDigLoop = {
            timeline: [scanOrDig],
            loop_function: function (data) {
                const last = data.values().slice(-1)[0];
                return parseInt(last.response) === 0;  // keep looping if they scanned
            }
        };

        // Feedback after each dig
        const digFeedback = {
            type: 'html-button-response',
            choices: [],    // no buttons
            stimulus: function () {
                // Grab all data, reverse it, and find the first trial where we actually dug
                const allData = jsPsych.data.get().values();
                const digData = allData
                    .slice()                      // copy
                    .reverse()                    // last trial first
                    .find(trial => trial.dug);    // only dig trials have `dug` defined

                return `
      <div id="balance">Gold: <strong>${currentMoney}</strong></div>
      ${digData.correct
                        ? `<p>You struck gold! (+${pReward})</p>`
                        : `<p>Better luck next time! (‚àí${pPenalty})</p>`
                    }
    `;
            },
            trial_duration: 1500
        };

        // Confidence slider after each dig
        const confidenceTrial = {
            type: 'html-slider-response',
            // Fill in stimulus & labels in on_start
            stimulus: '',
            labels: [],
            min: 0,
            max: 100,
            start: 50,
            step: 1,
            require_movement: true,
            data: { trial_part: 'confidence' },

            on_start: function (trial) {
                // grab all data, reverse, and find the most recent dig trial
                const all = jsPsych.data.get().values();
                const digData = all.slice().reverse().find(t => t.dug !== undefined);
                const choice = digData.dug; // either "core" or "surface"

                // set the question text
                trial.stimulus = `<p>How confident are you that the gold is at <strong>${choice}</strong>?</p>`;

                // set the endpoint and midpoint labels
                trial.labels = [
                    `Not confident that gold is at ${choice}`,
                    `Moderately confident that gold is at ${choice}`, // may need workshoping
                    `Very confident that gold is at ${choice}`
                ];
            },

            on_finish: function (data) {
                data.confidence = data.response;
                // ======== (#5) also tag indices on confidence row for easier joins later ========
                data.block_index = globalBlockIndex;
                data.trial_index = globalTrialIndex;
            }
        };


        // Comprehension Check
        // running tallies saved across attempts and will be saved in csv output
        const quizStats = {
            stay_put: { correct: 0, incorrect: 0 },
            noise_def: { correct: 0, incorrect: 0 },
            scan_tradeoff: { correct: 0, incorrect: 0 }
        };

        // helper function: creates a single-question loop with feedback and logging for csv
        function makeQuizQuestion({ qid, promptHTML, choices, correctIndex, feedbackHTML }) {
            let attempts = 0; // attempts for this question (resets if page reloads)

            const qTrial = {
                type: 'html-button-response',
                stimulus: promptHTML,
                choices: choices,
                data: { trial_part: 'instr', qid: qid },
                on_finish: function (d) {
                    attempts += 1;
                    d.attempt = attempts;
                    d.correct_index = correctIndex;
                    d.is_correct = (d.response === correctIndex);

                    // update totals
                    if (d.is_correct) quizStats[qid].correct += 1;
                    else quizStats[qid].incorrect += 1;

                    // copy running totals into this row so they get added to the CSV
                    d.correct_total = quizStats[qid].correct;
                    d.incorrect_total = quizStats[qid].incorrect;

                    // ======== (#5) indices on instruction rows as well ========
                    d.block_index = globalBlockIndex;
                    d.trial_index = globalTrialIndex;
                }
            };

            const feedbackTrial = {
                type: 'html-button-response',
                choices: function () {
                    const last = jsPsych.data.get().last(1).values()[0];
                    return last.is_correct ? [] : ['Try again'];
                },
                stimulus: function () {
                    const last = jsPsych.data.get().last(1).values()[0]; // the question we just answered
                    if (last.is_correct) {
                        return `<p>‚úÖ Correct.</p>`;
                    } else {
                        return `
                        <p>‚ùå Incorrect.</p>
                        <div style="margin-top:8px">${feedbackHTML}</div>
                        <p style="margin-top:8px">Please select the correct answer to continue.</p>
                        `;
                    }
                },
                trial_duration: function () {
                    const last = jsPsych.data.get().last(1).values()[0];
                    return last.is_correct ? 900 : null; // auto-advance if correct; else wait for button
                },
                data: {
                    trial_part: 'instr_feedback', qid: qid,
                    // ======== (#5) indices on instruction feedback rows ========
                    block_index: function () { return globalBlockIndex; },
                    trial_index: function () { return globalTrialIndex; }
                }
            };

            // repeat forever until the questions get answered correctly
            return {
                timeline: [qTrial, feedbackTrial],
                loop_function: function (loopData) {
                    // the first item in this mini-timeline is the question trial we just ran
                    const q = loopData.values().find(t => t.trial_part === 'instr' && t.qid === qid);
                    return !q.is_correct; // true ‚Üí repeat; false ‚Üí move on
                }
            };
        }

        // Q1: which action keeps you on the same asteroid?
        const quizQ1 = makeQuizQuestion({
            qid: 'stay_put',
            promptHTML: `<p><strong>1.</strong> Which action keeps you on the same asteroid and gather information about where to dig?</p>`,
            choices: ['üîç Scan', '‚õè Dig Core', 'üåê Dig Surface'],
            correctIndex: 0,
            feedbackHTML: `<p>Incorrect. Scanning both gives you information about the asteroid and does <em>not</em> end the trial. It provides some noisy information at a cost set by the company. You can <em>scan</em> repeatedly on the same asteroid.</p>`
        });

        // Q2: meaning of ‚Äúscanner accuracy 70%‚Äù
        const quizQ2 = makeQuizQuestion({
            qid: 'noise_def',
            promptHTML: `<p><strong>2.</strong> Our scanners are <strong>UNRELIABLE</strong> and they have scanner accuracy. Suppose scanner accuracy is 70%. What does this mean?</p>`,
            choices: [
                'I can trust that the scanner is probably correct all of the time.',
                'The scanner is not reliable at all, so I should ignore the scanning results.',
                'The scanner is only giving the correct location of the gold 70% of the time.'
            ],
            correctIndex: 2,
            feedbackHTML: `<p>Incorrect. The ‚Äú70%‚Äù means the scanner‚Äôs message matches the true gold location 70% of the time.</p>`
        });

        // Q3: scanning trade-off
        const quizQ3 = makeQuizQuestion({
            qid: 'scan_tradeoff',
            promptHTML: `<p><strong>3.</strong> Suppose you got three "surface" readings in a row and no "core" readings. Should you dig at the surface?</p>`,
            choices: [
                'Yes, that is a strong indication of gold on the surface.',
                'No, the scanner is unreliable, so you should ignore it.',
                'Maybe. It depends on the scanner reliability, the cost of a scan, and the company reward and punishment.'
            ],
            correctIndex: 2,
            feedbackHTML: `<p>Incorrect. The right time to dig depends on scanner accuracy, scan cost, and your reward/penalty structure. You should not just rely on last few scanner readings.</p>`
        });



        // Build the experiment timeline 
        const timeline = [];

        // ======== (#2) Collect metadata before anything else runs ========
        timeline.push({ type: 'call-function', func: collectParticipantMetadata });

        //Instructions now broken into multiple pages due to length. 

        // Instructions as a single nav-able component (Next/Previous)
        const instrPages = [
            `<h2>Mining Task (Draft instructions)</h2>
             <p>In this experiment, you will pretend to work for an asteroid mining company in the year 3000.</p>
             <p>The company has sent mining drones all over the galaxy. Your job is to help us collect gold from asteroids.</p>
             <p>Each asteroid a mining drone lands on has gold at the surface or in the core.</p>
             <p>But we don't know whether gold is near the surface or in the core.</p>`,

            `<p>Your task is to decide whether to dig near the surface or into the core.</p>
             <p>If you dig where the gold is located, then you will get a reward as compensation from the company. However, the asteroids are <strong>fragile.</strong></p> 
             <p>So, once you dig, it will break apart and any remaining gold becomes unsalvageable.</p>  
             <p>If you dig in the incorrect location, you cannot get the gold and the company will penalize you by lowering your compensation.</p>  
             <p>To help you, you can pay a small amount to scan the asteroid. Unfortunately, the scanners are <strong>unreliable.</strong></p> 
             <p>You can scan each asteroid as many times as you want. But, scanning is costly and so, the company charges you given amount per scan.</p>`,

            `<p>You start with <strong>${STARTING_MONEY}</strong> gold.</p>
             <p>When you land on an asteroid, you have a options about what to do:</p>
             <p>üîç <strong>Scan</strong> (cost depends on the specific asteroid field): you get noisy info about the location of the gold.</p>
             <p>‚õè <strong>Dig Core</strong> or üåê <strong>Dig Surface</strong>.</p>
             <p>If you select the correct location to dig: You win gold.</p> 
             <p>If you select the incorrect location to dig: You lose gold.</p>
             <p>Scan as many times as you like to gain information about the gold location.</p>`,

            `<p>You only get to pick a dig location once for each asteroid. So please make sure you're ready to dig in which ever location before doing so.</p>
             <p>The scanner's reliability, cost of using the scanner, reward, and punishment are set by the company for each particular asteroid. You will be told their amounts each time.</p>
             <p>Your compensation for the experiment partially depends on your <strong>total gold balance.</strong></p>`,

            `<p>Before we send you to the first asteroid field, we will check your understanding of the actions available and your role in the mission.</p>
             <p>Press <strong>Next</strong> to begin. Press <strong>Previous</strong> to review.</p>`
        ];

        timeline.push({
            type: 'instructions',
            pages: instrPages,
            show_clickable_nav: true,
            allow_backward: true,
            button_label_next: 'Next',
            button_label_previous: 'Previous'
        });


        // comprehension check ‚Äì each question loops until correct - Joe's preference
        timeline.push(quizQ1, quizQ2, quizQ3);


        // initialize first asteroid
        timeline.push({ type: 'call-function', func: resetAsteroid });

        // blocks
        for (let b = 0; b < N_BLOCKS; b++) {

            // set current block index so the main trial screen shows the right block number
            timeline.push({
                type: 'call-function',
                func: () => { globalBlockIndex = b; applyBlockParams(b); }
            });

            // block reminder parameter reminder text
            // block reminder parameter reminder text (HUD-styled; wording unchanged)
            timeline.push({
                type: 'html-button-response',
                stimulus: function () {
                    return `
      <div class="hud">
        <div class="hud-header">
          <div class="hud-balance" id="balance">Gold: <strong>${currentMoney}</strong></div>
          <div class="hud-meta">
            <div>Asteroid Field ${b + 1} of ${N_BLOCKS}</div>
            <div>Your balance carries over.</div>
          </div>
        </div>

        <div class="hud-grid hud-stack">
          <div class="hud-card">
            <h3>Asteroid Field ${b + 1} of ${N_BLOCKS}</h3>
            <p>You have now travelled to a new asteroid field.</p>
            <div class="hud-divider"></div>
            <p>The company has determined new values for scanner reliability, cost, reward and penalty for this asteroid field:</p>
            <div class="hud-divider"></div>
            <p>Scanner accuracy: <strong>${Math.round(pNoise * 100)}%</strong></p>
            <p>Scan cost: <strong>${pScanCost}</strong> gold</p>
            <p>Reward: <strong>+${pReward}</strong> gold</p>
            <p>Penalty: <strong>‚àí${pPenalty}</strong> gold</p>
            <div class="hud-divider"></div>
            <p>Press <strong>Continue</strong> when ready.</p>
          </div>
        </div>
      </div>
    `;
                },
                choices: ['Continue'],
                // style the Continue button like the HUD controls
                button_html: '<button class="jspsych-btn hud-btn">%choice%</button>',
                on_load: function () {
                    const g = document.getElementById('jspsych-html-button-response-btngroup');
                    if (g) g.classList.add('hud-actions');
                }
            });


            // trials
            for (let t = 0; t < TRIALS_PER_BLOCK; t++) {
                // record which trial (within the current block) we're on
                timeline.push({
                    type: 'call-function',
                    func: () => { globalTrialIndex = t; }
                });

                timeline.push(scanOrDigLoop);
                timeline.push(confidenceTrial);
                timeline.push(digFeedback);
                timeline.push({ type: 'call-function', func: resetAsteroid });
            }
        }

        // Transition page before questionnaires
            timeline.push({
                type: 'html-button-response',
                stimulus: `
                <h3>Questionnaires</h3>
                <p>The mining trials are complete. The next section asks about your usual thoughts, feelings, and habits in everyday life.</p>
                <p>Please answer honestly based on your typical experience. There are no right or wrong answers. Each questionnaire will include its own instructions. Follow those as written.</p>
                <p>Some items refer to topics such as low mood, worry, or sleep. If any question feels uncomfortable, you may pause for a period. You may also leave the experiment at any time. Though this will affect your compensation. This section is not timed, so take the time you need.</p>
                <p>When you are ready, select Begin Questionnaires.</p>
  `,
                choices: ['Begin Questionnaires']
            });


        // Questionnaires Section

        // Reusable scales to help with randomization
        const Q_SCALES = {
            often4: ['Never', 'Rarely', 'Sometimes', 'Often'],
            agree5: ['Strongly disagree', 'Disagree', 'Neither agree nor disagree', 'Agree', 'Strongly agree'],
            agree4: ['Do not agree', 'Agree slightly', 'Agree moderately', 'Agree very much'],
            often5: ['Never', 'Rarely', 'Sometimes', 'Often', 'Almost always'],
            typical5: ['Not at all typical of me', 'Not very typical of me', 'Somewhat typical of me', 'Fairly typical of me', 'Very typical of me'],
            freq5: ['Never', 'Rarely', 'Sometimes', 'Often', 'Always'],
            days4: ['Not at all', 'Several days', 'More than half the days', 'Nearly every day']
        };

        const DEFAULT_SCALE = Q_SCALES.agree5;  // defualt scale set as agree5 


        // Question sets 
        const Q_SETS = [
            {
                key: 'rrs',
                title: '',
                preamble: 'Look at the scale below and please tell us if you never, sometimes, often, or always think or do each one when you feel down, sad, or depressed. Please indicate what you generally do, not what you think you should do.',
                optionsKey: 'often4',
                items: [
                    `Think about how alone you feel.`,
                    `Think "I won't be able to do my job if I don't snap out of this."`,
                    `Think about your feelings of fatigue and achiness.`,
                    `Think about how hard it is to concentrate.`,
                    `Think "What am I doing to deserve this?"`,
                    `Think about how passive and unmotivated you feel.`,
                    `Analyze recent events to try to understand why you are depressed.`,
                    `Think about how you don't seem to feel anything anymore.`,
                    `Think "Why can't I get going?"`,
                    `Think "Why do I always react this way?"`,
                    `Go away by yourself and think about why you feel this way.`,
                    `Write down what you are thinking and analyze it.`,
                    `Think about a recent situation, wishing it had gone better.`,
                    `Think "I won't be able to concentrate if I keep feeling this way."`,
                    `Think "Why do I have problems other people don't have?"`,
                    `Think "Why can't I handle things better?"`,
                    `Think about how sad you feel.`,
                    `Think about all your shortcomings, failings, faults, mistakes.`,
                    `Think about how you don't feel up to doing anything.`,
                    `Analyze your personality to try to understand why you are depressed.`,
                    `Go someplace alone to think about your feeling.`,
                    'Think about how angry you are with yourself.'
                ],
                horizontal: false
            },
            {
                key: 'pswq',
                title: '',
                preamble: 'Think about how typical each statement is for you.',
                optionsKey: 'typical5',
                items: [
                    "If I do not have enough time to do everything, I do not worry about it.",
                    "My worries overwhelm me.",
                    "I do not tend to worry about things.",
                    "Many situations make me worry.",
                    "I know I should not worry about things, but I just cannot help it.",
                    "When I am under pressure I worry a lot.",
                    "I am always worrying about something.",
                    "I find it easy to dismiss worrisome thoughts.",
                    "As soon as I finish one task, I start to worry about everything else I have to do.",
                    "I never worry about anything.",
                    "When there is nothing more I can do about a concern, I do not worry about it any more.",
                    "I have been a worrier all my life.",
                    "I notice that I have been worrying about things.",
                    "Once I start worrying, I cannot stop.",
                    "I worry all the time.",
                    "I worry about projects until they are all done."
                ],
                horizontal: false
            },
            {
                key: 'ptq',
                title: '',
                preamble: 'In this questionnaire, you will be asked to describe how you typically think about negative experiences or problems. Please read the following statements and rate the extent to which they apply to you when you think about negative experiences or problems.',
                optionsKey: 'often5',
                items: [
                    'The same thoughts keep going through my mind',
                    'Thoughts intrude into my mind.',
                    'I cannot stop dwelling on my thoughts.',
                    'I think about many problems without solving any of them.',
                    'I cannot do anything else while thinking about my problems',
                    'My thoughts repeat themselves.',
                    'Thoughts come to my mind without me wanting them to.',
                    'I get stuck on certain issues and cannot move on',
                    'I keep asking myself questions without finding an answer.',
                    'My thoughts prevent me from focusing on other things.',
                    'I keep thinking about the same issue all the time.',
                    'Thoughts just pop into my mind.',
                    'I feel driven to continue dwelling on the same issue.',
                    'My thoughts are not much help to me',
                    'My thoughts take up all my attention.'
                ],
                horizontal: false
            },

            {
                key: 'MCQ30-F1',
                title: '',
                preamble: ' Please read each belief carefully and indicate how much you generally agree with each one.',
                optionsKey: 'agree4',
                items: [
                    "I do not trust my memory.",
                    "I have a poor memory.",
                    "I have little confidence in my memory for actions.",
                    "I have little confidence in my memory for places.",
                    "I have little confidence in my memory for words and names.",
                    "My memory can mislead me at times."
                ],
                horizontal: false
            },

            {
                key: 'MCQ30-F2',
                title: '',
                preamble: ' Please read each belief carefully and indicate how much you generally agree with each one.',
                optionsKey: 'agree4',
                items: [
                    "Worrying helps me to get things sorted out in my mind.",
                    "Worrying helps me cope.",
                    "I need to worry in order to work well.",
                    "Worrying helps me to solve problems.",
                    "I need to worry in order to remain organised.",
                    "Worrying helps me to avoid problems in the future."
                ],
                horizontal: false
            },

            {
                key: 'MCQ30-F3',
                title: '',
                preamble: ' Please read each belief carefully and indicate how much you generally agree with each one.',
                optionsKey: 'agree4',
                items: [
                    "I am constantly aware of my thinking.",
                    "I pay close attention to the way my mind works.",
                    "I think a lot about my thoughts.",
                    "I constantly examine my thoughts.",
                    "I monitor my thoughts.",
                    "I am aware of the way my mind works when I am thinking through a problem."
                ],
                horizontal: false
            },

            {
                key: 'MCQ30-F4',
                title: '',
                preamble: ' Please read each belief carefully and indicate how much you generally agree with each one.',
                optionsKey: 'agree4',
                items: [
                    "My worrying thoughts persist, no matter how I try to stop them.",
                    "When I start worrying I cannot stop.",
                    "I could make myself sick with worrying.",
                    "I cannot ignore my worrying thoughts.",
                    "My worrying could make me go mad.",
                    "My worrying is dangerous for me."
                ],
                horizontal: false
            },

            {
                key: 'MCQ30-F5',
                title: '',
                preamble: ' Please read each belief carefully and indicate how much you generally agree with each one.',
                optionsKey: 'agree4',
                items: [
                    "If I could not control my thoughts, I would not be able to function.",
                    "Not being able to control my thoughts is a sign of weakness.",
                    "I should be in control of my thoughts all of the time.",
                    "It is bad to think certain thoughts.",
                    "If I did not control a worrying thought and then it happened, it would be my fault.",
                    "I will be punished for not controlling certain thoughts."

                ],
                horizontal: false
            },
        ];

        // ---- PHQ-8 always-last questionnaire (not randomized) ----
        const ALWAYS_LAST = {
            key: 'PHQ-8',
            title: 'Patient Health Questionnaire',
            preamble: 'Over the last 2 weeks, how often have  you been bothered by any of the following problems?:',
            optionsKey: 'days4',
            items: [
                "Little interest or pleasure in doing things.",
                "Feeling down, depressed, irritable, or hopeless.",
                "Trouble falling or staying asleep, or sleeping too much.",
                "Feeling tired or having little energy.",
                "Poor appetite or overeating.",
                "Feeling bad about yourself ‚Äî or that you are a failure or have let yourself or your family down.",
                "Trouble concentrating on things, such as school work, reading, or watching television.",
                "Moving or speaking so slowly that other people could have noticed? Or the opposite ‚Äî being so fidgety or restless that you have been moving around a lot more than usual."
            ],
            horizontal: false
        };

        // ---- Helper: build a jsPsych survey trial from a set ----
        function makeSurveyBlock(set) {
            const setOptions =
                set.options ||
                (set.optionsKey ? Q_SCALES[set.optionsKey] : null) ||
                DEFAULT_SCALE;

            const questions = set.items.map((it, i) => {
                // Allow strings or rich objects per item
                const item = (typeof it === 'string') ? { prompt: it } : it;

                // Decide options for this item (item overrides > set options > default)
                const itemOptions =
                    item.options ||
                    (item.optionsKey ? Q_SCALES[item.optionsKey] : null) ||
                    setOptions ||
                    DEFAULT_SCALE;

                // Allow per-item required/horizontal overrides; else fall back to set or defaults
                const required =
                    (typeof item.required === 'boolean') ? item.required :
                        (typeof set.required === 'boolean') ? set.required : true;

                const horizontal =
                    (typeof item.horizontal === 'boolean') ? item.horizontal :
                        (typeof set.horizontal === 'boolean') ? set.horizontal : true;

                return {
                    prompt: item.prompt,
                    name: `${set.key}_${i + 1}`,   // column name in CSV
                    options: itemOptions,
                    required: required,
                    horizontal: horizontal
                };
            });

            return {
                type: 'survey-multi-choice',
                preamble: `<h3>${set.title}</h3>${set.preamble ? `<p>${set.preamble}</p>` : ''}`,
                questions: questions,
                randomize_question_order: true,  // shuffle items within this questionnaire
                button_label: 'Next',
                data: { questionnaire: set.key }
            };
        }

        // ---- Add questionnaires to the timeline ----
        const randomizedSets = jsPsych.randomization.repeat(Q_SETS, 1); // shuffle the 4 sets
        randomizedSets.forEach(set => timeline.push(makeSurveyBlock(set)));
        timeline.push(makeSurveyBlock(ALWAYS_LAST)); // fixed last

        // ---- Demographics ----
            const DEMOGRAPHICS_SET = {
                key: 'demographics',
                title: 'Demographics',
                preamble: 'The following questions are optional. You may skip any question by choosing Prefer not to say.',
                required: false,            // make every item optional
                horizontal: false,          // vertical layout for clarity
                items: [
                    {
                        prompt: 'Age', name: 'demo_age', optionsKey: null, options: [
                            '18‚Äì24', '25‚Äì34', '35‚Äì44', '45‚Äì54', '55‚Äì64', '65+', 'Prefer not to say'
                        ]
                    },
                    {
                        prompt: 'Gender identity', name: 'demo_gender', optionsKey: null, options: [
                            'Woman', 'Man', 'Nonbinary', 'Prefer not to say'
                        ]
                    },
                    {
                        prompt: 'Hispanic or Latino/a/x origin', name: 'demo_ethnicity', optionsKey: null, options: [
                            'Yes', 'No', 'Prefer not to say'
                        ]
                    },
                    {
                        prompt: 'Race', name: 'demo_race', optionsKey: null, options: [
                            'American Indian or Alaska Native',
                            'Asian',
                            'Black or African American',
                            'Native Hawaiian or Other Pacific Islander',
                            'White',
                            'Another race',
                            'Prefer not to say'
                        ]
                    },
                    {
                        prompt: 'Highest level of education completed', name: 'demo_education', optionsKey: null, options: [
                            'Some high school',
                            'High school diploma or GED',
                            'Some college',
                            "Bachelor's degree",
                            'Some graduate school',
                            'Graduate or professional degree',
                            'Prefer not to say'
                        ]
                    },
                    {
                        prompt: 'Primary language', name: 'demo_language', optionsKey: null, options: [
                            'English', 'Spanish', 'Chinese', 'Other', 'Prefer not to say'
                        ]
                    },
                    {
                        prompt: 'English proficiency', name: 'demo_english', optionsKey: null, options: [
                            'Native', 'Fluent', 'Conversational', 'Basic', 'Prefer not to say'
                        ]
                    },
                    {
                        prompt: 'Current residence', name: 'demo_residence', optionsKey: null, options: [
                            'United States', 'Outside the United States', 'Prefer not to say'
                        ]
                    },
                    {
                        prompt: 'Handedness', name: 'demo_handedness', optionsKey: null, options: [
                            'Right', 'Left', 'Ambidextrous', 'Prefer not to say'
                        ]
                    },
                    {
                        prompt: 'Device used for this study', name: 'demo_device', optionsKey: null, options: [
                            'Desktop or laptop', 'Tablet', 'Mobile phone', 'Prefer not to say'
                        ]
                    }
                ]
            };



        // final screen
        timeline.push({
            type: 'html-button-response',
            stimulus: function () {
                return `
      <h2>Congratulations on a successful space mining adventure!</h2>
      <p>Your final balance: <strong>${currentMoney}</strong> gold.</p>
      <p>Thank you for participating in our experiments.</p>
    `;
            },
            choices: ['Finish and download'] // 
        });

        // launch the experiment
        jsPsych.init({
            timeline: timeline,
            display_element: document.getElementById('jspsych-target'),
            on_finish: function () {
                // Prefer Prolific PID for filename if present
                const q = new URLSearchParams(window.location.search);
                const prolific_pid = q.get('PROLIFIC_PID');

                // If you didn't define PROLIFIC_COMPLETION_URL earlier, populate it from the querystring.
                // (This preserves your original redirect check below.)
                if (typeof window.PROLIFIC_COMPLETION_URL === 'undefined' || !window.PROLIFIC_COMPLETION_URL) {
                    window.PROLIFIC_COMPLETION_URL = q.get('PROLIFIC_REDIRECT') || null;
                }

                const pidForFile = (prolific_pid || PARTICIPANT_ID || 'NA').replace(/[^a-zA-Z0-9_-]/g, '_');
                const tsSafe = (START_TIMESTAMP || new Date().toISOString()).replace(/[:]/g, '-');
                const fname = `mining_task_${pidForFile}_${tsSafe}.csv`;

                // Trigger CSV download
                jsPsych.data.get().localSave('csv', fname);

                // ---- Save to Google Sheet via Apps Script (non-blocking) ----
                const SAVE_URL = 'https://script.google.com/macros/s/AKfycbz9GoKyRM6eojhuKEbxt3SAyodGB4muLMBcfxwalcq08wlpdNLC-7Eub-S-nTBnHTHVWw/exec'; // <-- THIS MUST ALLIGN WITH GOOGLE APPS URL

                try {
                    const payload = {
                        file_name: fname,
                        prolific_pid: prolific_pid || 'NA',
                        task_version: (typeof TASK_VERSION !== 'undefined' ? TASK_VERSION : 'NA'),
                        start_timestamp: START_TIMESTAMP || '',
                        study_id: q.get('STUDY_ID') || null,
                        session_id: q.get('SESSION_ID') || (typeof SESSION_ID !== 'undefined' ? SESSION_ID : null),
                        rows: jsPsych.data.get().values() // all jsPsych rows as JSON
                    };

                    // Fire-and-forget; keepalive helps when the tab is closing
                    fetch(SAVE_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload),
                        keepalive: true
                    }).catch(() => { /* swallow network errors so they don't affect redirect */ });
                } catch (_) {
                    // Never let saving errors interrupt the participant
                }

                // If this was a Prolific participant, send them to the completion URL
                if (prolific_pid && PROLIFIC_COMPLETION_URL) {
                    // Short delay so the download dialog can appear first
                    setTimeout(function () {
                        window.location.href = PROLIFIC_COMPLETION_URL;
                    }, 600);
                }
            }

            });


    </script>
</body>

</html>